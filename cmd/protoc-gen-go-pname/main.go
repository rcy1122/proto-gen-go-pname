package main

import (
	"flag"
	"fmt"
	"log"
	"os"

	gengo "google.golang.org/protobuf/cmd/protoc-gen-go/internal_gengo"
	"google.golang.org/protobuf/compiler/protogen"
)

const protocGenGoPNameVersion = "v0.0.1"

var (
	flags   flag.FlagSet
	pkgName string
)

func main() {
	debug := true
	if debug {
		l := log.Default()
		l.SetOutput(os.Stderr)
		l.SetFlags(log.Lshortfile)
	}
	flags.StringVar(&pkgName, "pkg_name", "", "generate codes for enums by the name")
	protogen.Options{ParamFunc: flags.Set}.Run(generate)
}

func generate(gen *protogen.Plugin) error {
	if pkgName == "" {
		return fmt.Errorf("pkg_name is required! ")
	}
	gen.SupportedFeatures = gengo.SupportedFeatures
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}

		if string(file.GoPackageName) != pkgName {
			continue
		}
		filename := file.GeneratedFilenamePrefix + ".pb.pname.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		genGeneratedHeader(gen, g, file)
		g.P("package ", file.GoPackageName)
		g.P()

		for _, message := range file.Messages {
			for _, field := range message.Fields {
				g.P("func (x *", message.Desc.Name(), ")", "Get", field.GoName, "Name() string {")
				g.P("return \"", field.Desc.JSONName(), "\"")
				g.P("}")
				g.P()
			}
		}
	}
	return nil
}

func genGeneratedHeader(gen *protogen.Plugin, g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-go-pname. DO NOT EDIT.")
	g.P("// versions:")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc-gen-go-pname ", protocGenGoPNameVersion)
	g.P("// \tprotoc        ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
}
